---
phase: 3
plan: 1
wave: 1
---

# Plan 3.1: Security Audit & SQLi Testing

## Objective
Final verification of the security measures implemented (parameterized queries and input validation) to ensure the system is proof against SQL injection as per the user's primary requirement.

## Context
- .gsd/SPEC.md
- backend/main.py
- scripts/test_auth.py (baseline test)

## Tasks

<task type="auto">
  <name>Automated Security Scan</name>
  <files>scripts/security_audit.py</files>
  <action>
    Create a more comprehensive security test script `scripts/security_audit.py` that tests multiple SQL injection vectors:
    - Tautologies (`' OR '1'='1`)
    - Union Based (testing if extra data can be leaked)
    - Error Based (testing if DB errors are leaked)
    - Commenting out queries (`admin'--`)
    Verify that all payloads are either blocked by Pydantic (validation error) or neutralized by SQLite (no data returned).
  </action>
  <verify>Run `python scripts/security_audit.py` and ensure 100% of payloads are safely handled.</verify>
  <done>Automated proof that common SQLi vectors are neutralized.</done>
</task>

<task type="checkpoint:human-verify">
  <name>UAT: Manual Login & Registration</name>
  <files>frontend/login.html, frontend/signup.html</files>
  <action>
    Perform a manual walk-through:
    1. Register a new user.
    2. Try to register the same user again (should fail).
    3. Login with correct credentials.
    4. Try to login with a SQL injection payload in the browser.
    5. Logout.
  </action>
  <verify>All steps behave as expected in the UI.</verify>
  <done>User experience is verified and security is confirmed in the browser.</done>
</task>

## Success Criteria
- [ ] Automated security audit passes with 0 vulnerabilities detected.
- [ ] Manual UAT confirms a smooth and safe user experience.
